<!DOCTYPE html><html lang="en"><head><title>Differences Between Proof of Storage/Space/Replication</title><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="manifest" href="/site.webmanifest"><link rel="stylesheet" href="/css/highlight/xcode.min.css"><link rel="stylesheet" href="/css/bootstrap/bootstrap-tooltips.css"><link rel="stylesheet" href="/css/post.css"><script src="/js/jquery.min.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="smallyu‘s Blog" type="application/atom+xml">
</head><body><script>if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent)) {
  document.body.classList.add('mobile')
}</script><div><div class="inner"><h1>Differences Between Proof of Storage/Space/Replication</h1><div class="time">2022-12-20</div><ul class="tags"><li><span>#</span><a href="/tags/Consensus-Mechanism/">Consensus Mechanism</a></li><li><span>#</span><a href="/tags/File-Proof/">File Proof</a></li></ul><h3 id="Timeline"><a href="#Timeline" class="headerlink" title="Timeline"></a>Timeline</h3><style>
table {
    display: inline;
}
</style>

<center>

<table>
<thead>
<tr>
<th>Abbreviation</th>
<th>Full Name</th>
<th>Year</th>
</tr>
</thead>
<tbody><tr>
<td>PDP</td>
<td>Provable Data Possession</td>
<td>2007</td>
</tr>
<tr>
<td>PORs</td>
<td>Proofs of Retrievability</td>
<td>2007</td>
</tr>
<tr>
<td>PoS</td>
<td>Proofs of Storage</td>
<td>2009</td>
</tr>
<tr>
<td>PoS</td>
<td>Proofs of Space</td>
<td>2013</td>
</tr>
<tr>
<td>PoST</td>
<td>Proofs of Space-Time</td>
<td>2016</td>
</tr>
<tr>
<td>PoRep</td>
<td>Proof of Replication</td>
<td>2017</td>
</tr>
<tr>
<td>PoC</td>
<td>Proof of Capacity</td>
<td>2017</td>
</tr>
</tbody></table>
</center>

<h3 id="Proofs-of-Storage"><a href="#Proofs-of-Storage" class="headerlink" title="Proofs of Storage"></a>Proofs of Storage</h3><p>PDP and PORs were independently published in 2007, each having its own advantages and disadvantages in terms of file proof methods, addressing different branches of the same problem.</p>
<p>The concept of PoS (Proofs of Storage) emerged as early as 2009, serving as a general term for interactive protocols where a client verifies files on a server, encompassing both PDP and PORs. For example, the paper “Proofs of Storage from Homomorphic Identification Protocols,” with Giuseppe Ateniese as the first author.</p>
<p>Since blockchain was not well-developed in 2009, PoS (Proofs of Storage) had no relation to consensus mechanisms and merely shared an acronym with PoS (Proof of Stake) without any actual connection.</p>
<p>PDP and PORs are predecessors to PoS, which unified them under a single name.</p>
<h3 id="Proofs-of-Space"><a href="#Proofs-of-Space" class="headerlink" title="Proofs of Space"></a>Proofs of Space</h3><p>PoS (Proofs of Space) began with the 2013 paper “Proofs of Space,” with Stefan Dziembowski as the first author.</p>
<p>Coincidentally, PoS (Proofs of Space) and PoS (Proofs of Storage) share the same abbreviation, which can sometimes cause confusion. In this section, PoS refers to Proofs of Space.</p>
<p>The concept of PoS aims to parallel PoW (Proof of Work). Hence, from PoS onwards, it is a concept within blockchain, serving as a consensus mechanism.</p>
<p>PoW involves mining using CPU power, whereas PoS proposes mining using disk capacity, seeking ways to prove a server has a certain amount of disk space.</p>
<p>The most basic method involves a client generating a file, for example, 1GB, sending it to the server, and then verifying the server has saved that file, thereby proving the server indeed has 1GB of disk space. However, this method is too cumbersome, consuming the client’s disk space and putting immense pressure on network transmission.</p>
<p>PoS offers a method using a data structure known as hard to pebble graphs, such as a Merkle hash tree. This data structure’s feature is that generating upper-level data must rely on lower-level data.</p>
<p>For example, in a system using a Merkle hash tree, a client can request the server to return the entire chain of a certain upper-level node, and then verify the path’s correctness. Cross-verifying multiple paths can generally ensure the server’s reliability.</p>
<h3 id="Proofs-of-Space-Time"><a href="#Proofs-of-Space-Time" class="headerlink" title="Proofs of Space-Time"></a>Proofs of Space-Time</h3><p>PoST (Proofs of Space-Time) emerged in 2016 with the paper “Simple Proofs of Space-Time and Rational Proofs of Storage,” with Tal Moran as the first author.</p>
<p>PoST builds upon the PoS (Proofs of Space) scheme because while PoS can prove a server has a certain amount of disk space, it cannot prove that the server’s capacity consistently remains at the expected level. For example, during verification, the server’s disk space is 1GB, but once verification ends, the server uses the space for other purposes. During the next verification, the server regenerates the 1GB file for verification.</p>
<p>Hence, PoS suggests verifying every minute to ensure the server’s honesty. This is clearly not a smart approach.</p>
<p>PoST aims to solve this problem by increasing the difficulty of the initialization phase, that is, the phase where PoS generates the file, ensuring that the server must spend enough time to generate the file.</p>
<p>To ensure sufficient time is needed, PoW (Proof of Work) can be used, such as computing 2^30 hash values, which implies a certain amount of time spent.</p>
<p>PoST combines PoW and PoS by requiring the server to spend enough time generating the file during the initialization phase and then verifying the file generated during the proof phase.</p>
<h3 id="Proof-of-Replication"><a href="#Proof-of-Replication" class="headerlink" title="Proof of Replication"></a>Proof of Replication</h3><p>PoRep (Proof of Replication) originates from the 2017 paper “Proof of Replication,” with Juan Bene as the first author.</p>
<p>PoRep is a type of Proofs of Storage and is a research outcome of Protocol Labs, which also developed IPFS and Filecoin. PoRep is the consensus mechanism used by Filecoin.</p>
<p>PoRep builds upon Proofs of Space and Proofs of Retrievability, adding the capability to distinguish the number of replicas on the server. The approach is relatively simple: during the tag generation phase, a unique identifier is attached to each replica, making each replica unique.</p>
<p>Because Filecoin operates in a decentralized network, it needs to ensure multiple replicas exist throughout the network. If nodes collude maliciously, previous proof methods are inadequate, so Filecoin employs the PoRep consensus mechanism.</p>
<p>The 2017 version of PoRep is relatively simple. The 2018 version introduces the use of Depth Robust Graphs data structures. The paper is titled “PoReps: Proofs of Space on Useful Data,” with Ben Fisch as the first author.</p>
<h3 id="Proof-of-Capacity"><a href="#Proof-of-Capacity" class="headerlink" title="Proof of Capacity"></a>Proof of Capacity</h3><p>PoC (Proof of Capacity) is a consensus mechanism used by the Burstcoin blockchain in 2017.</p>
<p>PoC provides a mining method where generating new blocks requires a nonce value:</p>
<pre><code>1 nonce = 8192 hash value = 4095 scoops
</code></pre>
<p>The hash value is calculated using the Shabal hash function, with every two hash values forming one scoop.</p>
<p>A scoop number is randomly selected from 0 to 4095, and then combined with the corresponding nonce to calculate a <code>deadline</code> value. Among all nodes, the one with the smallest deadline value can generate a new block.</p>
<p>PoC leans towards being a purely consensus mechanism.</p>
</div></div></body><script src="/js/highlight.min.js"></script><script src="/js/main.js"></script><script src="/js/bootstrap/bootstrap.min.js"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-2615E2THFJ"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-2615E2THFJ');</script></html>