<!DOCTYPE html><html lang="en"><head><title>A Compatibility Layer Integrating Geth and CometBFT</title><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="manifest" href="/site.webmanifest"><link rel="stylesheet" href="/css/highlight/xcode.min.css"><link rel="stylesheet" href="/css/bootstrap/bootstrap-tooltips.css"><link rel="stylesheet" href="/css/post.css"><script src="/js/jquery.min.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="smallyu‘s Blog" type="application/atom+xml">
</head><body><script>if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent)) {
  document.body.classList.add('mobile')
  var navbar = document.querySelector('nav.navbar');
  if (navbar) {
    navbar.classList.remove('navbar-fixed-top');
  }
}
</script><div><div class="inner"><h1>A Compatibility Layer Integrating Geth and CometBFT</h1><div class="time">2025-09-06</div><div class="title-margin"></div><h3 id="Project-Motivation"><a href="#Project-Motivation" class="headerlink" title="Project Motivation"></a>Project Motivation</h3><p>While analyzing the <a href="https://paragraph.com/@smallyu/%E5%AF%B9-arc-%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%88%86%E6%9E%90">Arc project</a>, I discovered something quite interesting: Arc first developed a Rust-based implementation of the Tendermint consensus algorithm called malachite, and then built a compatibility layer called malaketh-layered to interface between Reth and malachite. In other words, Arc’s blockchain architecture looks like this:</p>
<pre><code class="text">Reth -&gt; malaketh-layered -&gt; malachite
</code></pre>
<p>The result is a fully Ethereum-equivalent PBFT blockchain.</p>
<p>So, is there a similar architecture that directly combines Geth and CometBFT? Yes—<a href="https://paragraph.com/@smallyu/%E5%AF%B9-berachain-%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%88%86%E6%9E%90">Berachain</a> has developed something called <a href="https://github.com/berachain/beacon-kit">beacon-kit</a>, which does exactly that. In fact, Berachain’s mainnet was launched using this architecture.</p>
<p>However, beacon-kit has a problem: the code is overly “complex.” It introduces its own slot concept and includes Berachain’s economic model designs and LST staking mechanisms. So while beacon-kit is a viable engineering example of a Geth+CometBFT integration, it’s not built as a neutral tool—it comes bundled with opinionated features.</p>
<p>That’s why I believe a general-purpose, tool-focused compatibility layer is needed. I’m currently calling this project <strong>EthBFT</strong>. The goal of EthBFT is to provide a clean, open, minimal, tool-oriented architecture that integrates Geth and CometBFT. The architecture of the entire blockchain network would look like this:</p>
<pre><code class="text">Geth -&gt; EthBFT -&gt; CometBFT
</code></pre>
<p>EthBFT focuses on two main tasks:</p>
<ol>
<li>Obtaining block data from the Ethereum execution layer via the Engine API.</li>
<li>Submitting block data to CometBFT through the ABCI interface.</li>
</ol>
<p>Although Geth is used here as an example, EthBFT should be compatible with all Ethereum execution clients, since Ethereum’s execution and consensus clients are inherently interoperable via RPC. Therefore, EthBFT is expected to support all Ethereum execution clients.</p>
<p>EthBFT is designed to avoid code-level coupling with either Geth or CometBFT. It runs as an independent process and can be launched separately. Geth and CometBFT can also be started independently. All three components communicate solely through RPC interfaces, and the relevant RPC endpoint configurations are specified in EthBFT’s config files.</p>
<p>This ensures complete decoupling between the three components.</p>
<h3 id="Confidence-in-PBFT"><a href="#Confidence-in-PBFT" class="headerlink" title="Confidence in PBFT"></a>Confidence in PBFT</h3><p>I used to think blockchain development would trend toward novelty and decentralization, but that doesn’t seem to be the case.</p>
<p>From Celestia adopting PBFT in recent years, to Hyperliquid improving upon it, and now Arc implementing its own PBFT consensus, it’s clear that PBFT is still very much alive, especially in high-TPS scenarios.</p>
<p>PoW and PoS offer high decentralization but fall short on TPS and finality—areas where PBFT excels. In enterprise applications, decentralization isn’t always a priority.</p>
<p>You might ask: if decentralization isn’t a concern, why not just use a centralized server? But even when decentralization is compromised, blockchain still offers transparency and traceability of data—benefits that centralized systems often lack.</p>
<p>So, even as a nearly 30-year-old algorithm, PBFT continues to shine. There’s no issue at all in building a project around it.</p>
<h3 id="Project-Outlook"><a href="#Project-Outlook" class="headerlink" title="Project Outlook"></a>Project Outlook</h3><p>EthBFT probably won’t attract much market attention, because people mostly care about whether a chain can issue tokens or offer arbitrage opportunities—not its technical architecture.</p>
<p>EthBFT is just a tool. If a developer wants a fully Ethereum-compatible chain with high TPS, without EthBFT, what are the options? I won’t go into all the comparisons and setups here, but I believe EthBFT fills this gap, and in a non-intrusive way. The world needs a tool like this.</p>
<h3 id="Skepticism-Toward-AI-Technology"><a href="#Skepticism-Toward-AI-Technology" class="headerlink" title="Skepticism Toward AI Technology"></a>Skepticism Toward AI Technology</h3><p>The <a href="https://github.com/smallyunet/ethbft">smallyunet&#x2F;EthBFT</a> project already has a basic framework and can run a minimal version, archived as <a href="https://github.com/smallyunet/ethbft/tree/v0.0.1">v0.0.1</a>. At this stage, Geth’s block height increases steadily, CometBFT is producing blocks normally, and the two are synchronized in block height. Of course, it’s still very early, and given limited development time, there are definitely features that need improvement.</p>
<p>Previously, I said that <a href="/2025/04/12/%E9%BC%93%E5%90%B9Cursor%E7%9A%84%E4%BA%BA%E6%8A%80%E6%9C%AF%E8%83%BD%E5%8A%9B%E9%83%BD%E5%B7%AE/">those who hype Cursor lack technical competence</a>, because while AI can amplify your abilities, it can’t replace your understanding. All the code for EthBFT v0.0.1 was written by AI—yes, entirely—but this project has very clear goals. Try it yourself: without knowledge of Ethereum, Cosmos, or even general tech skills, can you have AI alone build a running project like EthBFT?</p>
<p>If your own understanding of the tech is unclear or flawed, AI won’t correct your mistakes—because it doesn’t know what “correct” means to you. AI will obediently follow your instructions, but if you’re vague, it will veer off-course, often leaving hidden traps in the code. You might think it’s done, but it either leaves a TODO or writes a bunch of unnecessary logic based on its own assumptions.</p>
<p>So getting AI to write correct code isn’t easy. First, <strong>you</strong> need to understand it, and then you need to monitor it closely. AI is, and always will be, just an assistant.</p>
</div></div></body><script src="/js/highlight.min.js"></script><script src="/js/main.js"></script><script src="/js/bootstrap/bootstrap.min.js"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-2615E2THFJ"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-2615E2THFJ');</script></html>