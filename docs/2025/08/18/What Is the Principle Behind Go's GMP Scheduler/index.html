<!-- Stable asset version (for cache busting without full-site churn)--><!DOCTYPE html><html lang="en"><head><title>What Is the Principle Behind Go's GMP Scheduler</title><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><!-- SEO basics--><meta name="description"><!-- Open Graph & Twitter--><link rel="canonical" href="https://en.smallyu.net/2025/08/18/What Is the Principle Behind Go's GMP Scheduler/"><meta property="og:title" content="What Is the Principle Behind Go's GMP Scheduler"><meta property="og:type" content="article"><meta property="og:url" content="https://en.smallyu.net/2025/08/18/What Is the Principle Behind Go's GMP Scheduler/"><meta property="og:site_name" content="smallyu‚Äòs Blog"><meta name="twitter:card" content="summary_large_image"><!-- Browser UI color--><meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#0f1115"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="manifest" href="/site.webmanifest"><!-- stylesheets--><!-- Use a stable, configurable asset version to prevent full-site churn on every build.--><!-- Set `asset_version` in theme _config.yml when you actually change CSS/JS.--><link rel="stylesheet" href="/css/xcode.min.css?v=2025-09-28.27"><link rel="stylesheet" href="/css/post.css?v=2025-09-28.27"><!-- unified typography overrides for both home and post pages--><link rel="stylesheet" href="/css/typography.css?v=2025-09-28.27"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="smallyu‚Äòs Blog" type="application/atom+xml">
</head><body><div><div class="inner"><h1>What Is the Principle Behind Go's GMP Scheduler</h1><div class="time">2025-08-18</div><div class="title-margin"></div><p><strong>Disclaimer</strong>: I look down on technical topics like ‚ÄúWhat is the principle behind Go‚Äôs GMP scheduler?‚Äù</p>
<p>I‚Äôm usually not interested in studying this type of question. But it‚Äôs been asked so frequently in interviews that I‚Äôm now setting aside 2 hours to understand it. On one hand, I want to see if there‚Äôs any real technical depth behind it; on the other hand, I‚Äôm writing down the answer here. But I won‚Äôt let this information stay in my brain‚Äînext time I‚Äôm asked in an interview, I‚Äôll still say I don‚Äôt know üòè</p>
<h3 id="Basic-Concepts"><a href="#Basic-Concepts" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><p>GMP is an acronym:</p>
<ul>
<li><strong>G (Goroutine)</strong>: A coroutine; every <code>go</code> statement adds a new G.</li>
<li><strong>M (Machine)</strong>: A system-level thread, similar to a thread in other languages.</li>
<li><strong>P (Processor)</strong>: The number of P equals <code>GOMAXPROCS</code>, typically the number of CPU cores.</li>
</ul>
<p>GMP means: spin up several M (threads) to execute G (goroutines), but at most P (cores) M‚Äôs can run in parallel.</p>
<h3 id="Three-Invariants"><a href="#Three-Invariants" class="headerlink" title="Three Invariants"></a>Three Invariants</h3><p>Here come some boring (and simplified) rules:</p>
<ol>
<li>Only M‚Äôs that obtain a P can execute tasks.</li>
<li>Runnable G‚Äôs reside in either a P‚Äôs local run queue or the global queue.</li>
<li>When an M becomes blocked (syscall&#x2F;cgo), it promptly hands over its P.</li>
</ol>
<p>These may sound confusing now, but they‚Äôll make more sense with the code examples later.</p>
<h3 id="GMP-Debug-Log"><a href="#GMP-Debug-Log" class="headerlink" title="GMP Debug Log"></a>GMP Debug Log</h3><p>Here‚Äôs a basic code file to demonstrate spawning a goroutine:</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
)

func main() &#123;
    var wg sync.WaitGroup
    wg.Add(1)
    go func() &#123;
        defer wg.Done()
        fmt.Println(&quot;Hello from goroutine&quot;)
    &#125;()
    wg.Wait()
&#125;
</code></pre>
<p>Run it with debug flags:</p>
<pre><code class="bash">go build demo0.go
GODEBUG=&#39;schedtrace=200,scheddetail=1&#39; ./demo0
</code></pre>
<p>Don‚Äôt use <code>go run</code>‚Äîit introduces extra runtime logs. The binary version‚Äôs logs are cleaner:</p>
<pre><code class="bash">SCHED 0ms: gomaxprocs=10 idleprocs=7 threads=5 spinningthreads=1 needspinning=0 idlethreads=0 runqueue=0 gcwaiting=false nmidlelocked=1 stopwait=0 sysmonwait=false
  P0: status=0 schedtick=0 syscalltick=0 m=nil runqsize=0 gfreecnt=0 timerslen=0
  P1: status=1 schedtick=0 syscalltick=0 m=2 runqsize=0 gfreecnt=0 timerslen=0
  ...
Hello from goroutine
</code></pre>
<p>These logs show:</p>
<ul>
<li>The first line starting with <code>SCHED</code> is a summary‚Äî10 P‚Äôs were launched (<code>gomaxprocs=10</code>).</li>
<li>Only <code>P1</code> is running, held by <code>M2</code>.</li>
<li><code>P0</code> is held by <code>M3</code> and is in <code>spinning</code> state (waiting for tasks).</li>
</ul>
<p>You don‚Äôt see the print-related G because it finishes too quickly‚ÄîGMP details can be viewed via debug logs like this.</p>
<h3 id="Preemptive-Scheduling"><a href="#Preemptive-Scheduling" class="headerlink" title="Preemptive Scheduling"></a>Preemptive Scheduling</h3><pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;runtime&quot;
    &quot;time&quot;
)

func busy(tag string, d time.Duration) &#123;
    end := time.Now().Add(d)
    x := 0
    for time.Now().Before(end) &#123;
        x++
    &#125;
    fmt.Println(tag, &quot;done&quot;, x)
&#125;

func main() &#123;
    runtime.GOMAXPROCS(1)
    go busy(&quot;A&quot;, 1500*time.Millisecond)
    busy(&quot;B&quot;, 1500*time.Millisecond)
&#125;
</code></pre>
<p>Sometimes ‚ÄúA‚Äù prints first, sometimes ‚ÄúB‚Äù.</p>
<p>We set <code>GOMAXPROCS(1)</code>, so only one P exists. Yet, Go‚Äôs GMP scheduler preempts every 10ms, meaning even if <code>go busy(&quot;A&quot;)</code> is running, it eventually yields, letting the main thread run <code>B</code>.</p>
<p>To visualize this more clearly:</p>
<pre><code class="go">func busy(tag string, d time.Duration) &#123;
    end := time.Now().Add(d)
    next := time.Now()
    for time.Now().Before(end) &#123;
        if time.Now().After(next) &#123;
            fmt.Print(tag, &quot; &quot;) // Print ~every 100ms
            next = time.Now().Add(100 * time.Millisecond)
        &#125;
    &#125;
    fmt.Println(tag, &quot;done&quot;)
&#125;
</code></pre>
<p>Sample output: <code>B A B A B A A B A B A B A B A B A B A B A B A B B A B A B A B done</code></p>
<p>This confirms that <code>A</code> and <code>B</code> alternate‚Äîthey‚Äôre interleaved due to GMP‚Äôs preemptive scheduler.</p>
<h3 id="P-Work-Stealing"><a href="#P-Work-Stealing" class="headerlink" title="P Work Stealing"></a>P Work Stealing</h3><pre><code class="go">package main

import (
    &quot;runtime&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

func spin(d time.Duration) &#123;
    deadline := time.Now().Add(d)
    for time.Now().Before(deadline) &#123;
    &#125;
&#125;

func main() &#123;
    runtime.GOMAXPROCS(1)

    const N = 120
    var wg sync.WaitGroup
    wg.Add(N)
    for i := 0; i &lt; N; i++ &#123;
        go func() &#123; defer wg.Done(); spin(500 * time.Millisecond) &#125;()
    &#125;

    time.Sleep(30 * time.Millisecond)

    runtime.GOMAXPROCS(4)
    wg.Wait()
&#125;
</code></pre>
<p>Initially all G‚Äôs go to one P. Then <code>GOMAXPROCS</code> is increased to 4‚Äînew P‚Äôs (P1‚ÄìP3) ‚Äústeal‚Äù tasks from P0‚Äôs queue.</p>
<p>Debug logs show:</p>
<pre><code class="bash">P0: runqsize=17
P1: runqsize=5
P2: runqsize=5
P3: runqsize=17
</code></pre>
<p>Initially, all G‚Äôs were with P0. Later, others came and took some.</p>
<h3 id="P‚Äôs-runq-and-the-Global-Queue"><a href="#P‚Äôs-runq-and-the-Global-Queue" class="headerlink" title="P‚Äôs runq and the Global Queue"></a>P‚Äôs runq and the Global Queue</h3><pre><code class="go">package main

import (
    &quot;runtime&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

func spin(d time.Duration) &#123;
    end := time.Now().Add(d)
    for time.Now().Before(end) &#123;
    &#125;
&#125;

func main() &#123;
    runtime.GOMAXPROCS(1)

    const N = 600
    var wg sync.WaitGroup
    wg.Add(N)
    for i := 0; i &lt; N; i++ &#123;
        go func() &#123; defer wg.Done(); spin(800 * time.Millisecond) &#125;()
    &#125;

    time.Sleep(500 * time.Millisecond)

    runtime.GOMAXPROCS(4)
    wg.Wait()
&#125;
</code></pre>
<p>Use debug to analyze:</p>
<pre><code class="bash">go build demo4.go   
GODEBUG=&#39;schedtrace=200,scheddetail=1&#39; ./demo4 &amp;&gt; demo4.log
</code></pre>
<p>Initial logs show:</p>
<pre><code class="bash">runqueue=0 // global queue
P0: runqsize=0
P1: runqsize=0
</code></pre>
<p>Later, P0 starts many G‚Äôs:</p>
<pre><code class="bash">P0: runqsize=204
runqueue=395 // global queue overflow
</code></pre>
<p>Default <code>runq</code> capacity is 256. Excess tasks go to the global queue. When P1‚ÄìP3 enter, they pick tasks from the global queue first‚Äînot by stealing.</p>
<p>If a P finds no work in its runq or the global queue, it checks netpoll (OS), and if that fails, it spins.</p>
<h3 id="Blocking-syscalls-Yield-P"><a href="#Blocking-syscalls-Yield-P" class="headerlink" title="Blocking syscalls Yield P"></a>Blocking syscalls Yield P</h3><pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;runtime&quot;
    &quot;time&quot;
)

func main() &#123;
    runtime.GOMAXPROCS(2)

    go func() &#123;
        time.Sleep(2 * time.Second)
        fmt.Println(&quot;blocking done&quot;)
    &#125;()

    go func() &#123;
        for i := 0; i &lt; 6; i++ &#123;
            time.Sleep(300 * time.Millisecond)
            fmt.Println(&quot;still running&quot;, i)
        &#125;
    &#125;()

    time.Sleep(3 * time.Second)
&#125;
</code></pre>
<p>Output:</p>
<pre><code class="bash">still running 0
still running 1
...
blocking done
</code></pre>
<p>Even though the first G blocks, the second keeps running‚ÄîGMP properly yields P when blocking occurs.</p>
<h3 id="Disable-Async-Preemption"><a href="#Disable-Async-Preemption" class="headerlink" title="Disable Async Preemption"></a>Disable Async Preemption</h3><pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;runtime&quot;
    &quot;time&quot;
)

func spin() &#123;
    for &#123; &#125;
&#125;

func main() &#123;
    runtime.GOMAXPROCS(1)
    go spin()
    time.Sleep(100 * time.Millisecond)
    fmt.Println(&quot;I should still print unless preemption is off&quot;)
&#125;
</code></pre>
<p>Two ways to run:</p>
<pre><code class="bash">go build demo7.go
GODEBUG=&#39;schedtrace=1000,scheddetail=1&#39; ./demo7
</code></pre>
<p>and:</p>
<pre><code class="bash">go build demo7.go
GODEBUG=&#39;schedtrace=1000,scheddetail=1,asyncpreemptoff=1&#39; ./demo7
</code></pre>
<p>With <code>asyncpreemptoff=1</code>, async preemption is disabled‚Äîthe print never happens due to infinite loop. This illustrates GMP‚Äôs ability to yield CPU, and what happens when it‚Äôs turned off.</p>
<h3 id="Go-Source-Code"><a href="#Go-Source-Code" class="headerlink" title="Go Source Code"></a>Go Source Code</h3><p>I didn‚Äôt dig deeply into the source. For example, constants for G&#x2F;M&#x2F;P are in <a href="https://github.com/golang/go/blob/master/src/runtime/runtime2.go#L18"><code>src/runtime/runtime2.go</code></a>:</p>
<img src="1.png" width="60%">

<p>And <code>runqputslow</code> in <a href="https://github.com/golang/go/blob/master/src/runtime/proc.go"><code>src/runtime/proc.go</code></a> handles queue overflow:</p>
<img src="2.png" width="60%">

<h3 id="Digging-Deeper"><a href="#Digging-Deeper" class="headerlink" title="Digging Deeper"></a>Digging Deeper</h3><p>This post is probably incomplete‚ÄîI‚Äôm not going any deeper. Some people may love diving into this.</p>
<p>GMP is an engineering implementation of a coroutine scheduler. Many care about the engineering details‚Äîtask queue management, preemption, yielding, etc. But underneath, all coroutine schedulers are based on continuation. Go just happens to spotlight coroutines. Other languages can implement their own coroutine schedulers too.</p>
<p>So here‚Äôs the question: if you love researching GMP, have you studied coroutine&#x2F;virtual thread&#x2F;async function&#x2F;process implementations in other languages? How do they differ from Go‚Äôs goroutines?</p>
<p>If my job someday requires a deep understanding of these, I‚Äôll learn them.</p>
<h3 id="Doubts"><a href="#Doubts" class="headerlink" title="Doubts"></a>Doubts</h3><p>I once said:</p>
<p>Go designed automatic garbage collection to reduce the mental load of memory management. Yet some interviewers go out of their way to master GC internals and quiz candidates on it. If you truly believe in using your brain to manage memory, why not just use Rust?</p>
<p>It‚Äôs like I‚Äôm learning to drive, and someone expects me to understand how internal combustion works before getting a license. I‚Äôm not building cars‚ÄîI‚Äôm driving one.</p>
<p>Same goes for Go‚Äôs <code>go</code> keyword. It was built to make concurrency easy. Yet some folks study its internals obsessively, and use that as a gauge of Go proficiency. Doesn‚Äôt that contradict the language‚Äôs intent? If a language needs you to understand scheduling internals to write good code, it has failed in its abstraction.</p>
<p>If you‚Äôre building programming languages or implementing schedulers, by all means, understand GMP thoroughly. Otherwise?</p>
</div></div></body><!-- Defer non-critical scripts for better performance--><script defer src="/js/jquery.min.js?v=2025-09-28.27"></script><script defer src="/js/highlight.min.js?v=2025-09-28.27"></script><script defer src="/js/main.js?v=2025-09-28.27"></script><script defer src="/js/lightbox.js?v=2025-09-28.27"></script><script defer src="/js/bootstrap.min.js?v=2025-09-28.27"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-5JRBZ6P1W3"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-5JRBZ6P1W3');</script></html>