<!DOCTYPE html><html lang="en"><head><title>Solana Smart Contract Development Tutorial (2)</title><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="manifest" href="/site.webmanifest"><link rel="stylesheet" href="/css/highlight/xcode.min.css"><link rel="stylesheet" href="/css/bootstrap/bootstrap-tooltips.css"><link rel="stylesheet" href="/css/post.css"><script src="/js/jquery.min.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="smallyu‘s Blog" type="application/atom+xml">
</head><body><script>if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent)) {
  document.body.classList.add('mobile')
  var navbar = document.querySelector('nav.navbar');
  if (navbar) {
    navbar.classList.remove('navbar-fixed-top');
  }
}
</script><div><div class="inner"><h1>Solana Smart Contract Development Tutorial (2)</h1><div class="time">2025-06-26</div><div class="title-margin"></div><blockquote>
<p>This is a beginner-friendly tutorial series that teaches Solana smart contract development from the very basics.</p>
<ul>
<li><a href="/2025/06/24/Solana%20Smart%20Contract%20Development%20Tutorial%20(1)/">Part 1</a>: Basic environment setup, deploying HelloWorld contract, on-chain contract interaction</li>
<li><a href="/2025/06/26/Solana%20Smart%20Contract%20Development%20Tutorial%20(2)/">Part 2</a>: Creating a minimal USDT contract model, custom data structures and methods</li>
<li><a href="/2025/06/28/Solana%20Smart%20Contract%20Development%20Tutorial%20(3)/">Part 3</a>: Using the official SPL library to reuse contract functionality and issue a standard token</li>
</ul>
</blockquote>
<p>Now that we’ve learned how to create, deploy, and call Solana smart contracts, let’s dive deeper into writing custom logic. We’ll walk through building a simplified USDT token contract to understand how smart contracts work on Solana.</p>
<h3 id="1-Create-a-Project"><a href="#1-Create-a-Project" class="headerlink" title="1. Create a Project"></a>1. Create a Project</h3><p>Use the command we’ve already learned to create a new project:</p>
<pre><code class="bash">anchor init usdt_clone
</code></pre>
<h3 id="2-Configuration-File"><a href="#2-Configuration-File" class="headerlink" title="2. Configuration File"></a>2. Configuration File</h3><p>Take a look at the <code>programs/usdt_clone/Cargo.toml</code> file. Cargo is Rust’s package manager, and <code>Cargo.toml</code> defines dependencies and their versions. You’ll see this line:</p>
<pre><code class="rust">[dependencies]
anchor-lang = &quot;0.31.1&quot;
</code></pre>
<p>The macros provided by Anchor—like <code>#[program]</code>, <code>#[account]</code>, etc.—are essential for Solana smart contracts. These macros instruct the Solana Virtual Machine (SVM) where the program logic and data structures are defined. Without this dependency, the project is just a regular Rust application.</p>
<h3 id="3-Contract-Address"><a href="#3-Contract-Address" class="headerlink" title="3. Contract Address"></a>3. Contract Address</h3><p>Open the main contract file: <code>usdt_clone/programs/usdt_clone/src/lib.rs</code>. The first line imports the Anchor types:</p>
<pre><code class="rust">use anchor_lang::prelude::*;
</code></pre>
<p>The second line defines the contract’s Program ID:</p>
<pre><code class="rust">declare_id!(&quot;CFmGdHuqDymqJYBX44fyNjrFoJx6wRkZPkYgZqfkAQvT&quot;);
</code></pre>
<p>This address is a valid Ed25529 public key. It’s randomly generated during project initialization, with the corresponding private key stored in <code>target/deploy/usdt_clone-keypair.json</code>.</p>
<h3 id="4-Data-Structures-for-Storage"><a href="#4-Data-Structures-for-Storage" class="headerlink" title="4. Data Structures for Storage"></a>4. Data Structures for Storage</h3><p>Right below <code>declare_id</code>, add this:</p>
<pre><code class="rust">#[account]
pub struct Mint &#123;
    pub decimals: u8,
    pub mint_authority: Pubkey,
&#125;
</code></pre>
<p>This struct stores token metadata: <code>decimals</code> defines precision (e.g., 6 for USDT), and <code>mint_authority</code> defines who can mint new tokens.</p>
<p>Now define another struct for user token accounts:</p>
<pre><code class="rust">#[account]
pub struct TokenAccount &#123;
    pub owner: Pubkey,
    pub balance: u64,
&#125;
</code></pre>
<h3 id="5-Account-Constraint-Structures"><a href="#5-Account-Constraint-Structures" class="headerlink" title="5. Account Constraint Structures"></a>5. Account Constraint Structures</h3><p>Delete the default <code>Initialize</code> struct:</p>
<pre><code class="rust">#[derive(Accounts)]
pub struct Initialize &#123;&#125;    // Delete this
</code></pre>
<p>And replace it with:</p>
<pre><code class="rust">#[derive(Accounts)]
pub struct InitMint&lt;&#39;info&gt; &#123;
    #[account(
        init, 
        payer = authority,
        space = 8 + 1 + 32
    )]
    pub mint: Account&lt;&#39;info, Mint&gt;,

    #[account(mut)]
    pub authority: Signer&lt;&#39;info&gt;,

    pub system_program: Program&lt;&#39;info, System&gt;,
&#125;
</code></pre>
<p>This structure defines the context for initializing a mint. The macro parameters indicate:</p>
<ul>
<li><code>init</code>: Create the account if it doesn’t exist.</li>
<li><code>payer = authority</code>: The <code>authority</code> account pays the creation fee.</li>
<li><code>space = 8 + 1 + 32</code>: Reserve 8 bytes for the discriminator, 1 byte for <code>u8</code>, and 32 for <code>Pubkey</code>.</li>
</ul>
<h3 id="6-Initialize-the-Token-Contract"><a href="#6-Initialize-the-Token-Contract" class="headerlink" title="6. Initialize the Token Contract"></a>6. Initialize the Token Contract</h3><p>Delete the default <code>initialize</code> function:</p>
<pre><code class="rust">#[program]
pub mod usdt_clone &#123;
    use super::*;

    pub fn initialize(ctx: Context&lt;Initialize&gt;) -&gt; Result&lt;()&gt; &#123;   // Delete
        msg!(&quot;Greetings from: &#123;:?&#125;&quot;, ctx.program_id);             // Delete
        Ok(())                                                    // Delete
    &#125;                                                             // Delete
&#125;
</code></pre>
<p>And replace it with:</p>
<pre><code class="rust">pub fn init_mint(ctx: Context&lt;InitMint&gt;, decimals: u8) -&gt; Result&lt;()&gt; &#123;
    let mint = &amp;mut ctx.accounts.mint;
    mint.decimals = decimals;
    mint.mint_authority = ctx.accounts.authority.key();
    Ok(())
&#125;
</code></pre>
<p>This function receives the context (containing accounts) and token precision, then initializes the <code>mint</code> account accordingly.</p>
<h3 id="7-Unit-Test"><a href="#7-Unit-Test" class="headerlink" title="7. Unit Test"></a>7. Unit Test</h3><p>Run a build to verify everything compiles:</p>
<pre><code class="bash">anchor build
</code></pre>
<p>Then open <code>usdt_clone/tests/usdt_clone.ts</code> and paste this:</p>
<pre><code class="ts">import anchor from &quot;@coral-xyz/anchor&quot;;
import &#123; Program &#125; from &quot;@coral-xyz/anchor&quot;;
import &#123; SystemProgram, Keypair &#125; from &quot;@solana/web3.js&quot;;
import &#123; assert &#125; from &quot;chai&quot;;

const &#123; AnchorProvider, BN &#125; = anchor;

describe(&quot;usdt_clone / init_mint&quot;, () =&gt; &#123;
  const provider = AnchorProvider.env();
  anchor.setProvider(provider);
  const program = anchor.workspace.UsdtClone as Program;

  const mintKey = Keypair.generate();

  it(&quot;creates a Mint with correct metadata&quot;, async () =&gt; &#123;
    const txSig = await program.methods
      .initMint(new BN(6))
      .accounts(&#123;
        mint: mintKey.publicKey,
        authority: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      &#125;)
      .signers([mintKey])
      .rpc();

    console.log(&quot;tx:&quot;, txSig);

    const mintAccount = await program.account.mint.fetch(mintKey.publicKey);

    assert.equal(mintAccount.decimals, 6);
    assert.equal(
      mintAccount.mintAuthority.toBase58(),
      provider.wallet.publicKey.toBase58()
    );
  &#125;);
&#125;);
</code></pre>
<p>Run the test:</p>
<pre><code class="bash">anchor test
</code></pre>
<p>If successful, you’ll see: <code>1 passing (460ms)</code></p>
<h3 id="8-Account-Initialization-amp-Token-Transfer"><a href="#8-Account-Initialization-amp-Token-Transfer" class="headerlink" title="8. Account Initialization &amp; Token Transfer"></a>8. Account Initialization &amp; Token Transfer</h3><p>Add these structs for account creation and token transfer logic:</p>
<pre><code class="rust">#[derive(Accounts)]
pub struct InitTokenAccount&lt;&#39;info&gt; &#123;
    #[account(init, payer = owner, space = 8 + 32 + 8)]
    pub token: Account&lt;&#39;info, TokenAccount&gt;,
    #[account(mut, signer)]
    pub owner: Signer&lt;&#39;info&gt;,
    pub system_program: Program&lt;&#39;info, System&gt;,
&#125;

#[derive(Accounts)]
pub struct Transfer&lt;&#39;info&gt; &#123;
    #[account(mut, has_one = owner)]
    pub from: Account&lt;&#39;info, TokenAccount&gt;,
    #[account(mut)]
    pub to: Account&lt;&#39;info, TokenAccount&gt;,
    #[account(signer)]
    pub owner: Signer&lt;&#39;info&gt;,
&#125;

#[error_code]
pub enum ErrorCode &#123;
    InsufficientFunds,
    ArithmeticOverflow,
&#125;
</code></pre>
<p>Now add the functions:</p>
<pre><code class="rust">pub fn init_token_account(ctx: Context&lt;InitTokenAccount&gt;) -&gt; Result&lt;()&gt; &#123;
  let token = &amp;mut ctx.accounts.token;
  token.owner = ctx.accounts.owner.key();
  token.balance = 1000;
  Ok(())
&#125;

pub fn transfer(ctx: Context&lt;Transfer&gt;, amount: u64) -&gt; Result&lt;()&gt; &#123;
  let from = &amp;mut ctx.accounts.from;
  let to   = &amp;mut ctx.accounts.to;

  require!(from.balance &gt;= amount, ErrorCode::InsufficientFunds);

  from.balance -= amount;
  to.balance = to
      .balance
      .checked_add(amount)
      .ok_or(ErrorCode::ArithmeticOverflow)?;

  Ok(())
&#125;
</code></pre>
<p>And test them with:</p>
<pre><code class="ts">const tokenA = Keypair.generate();
const tokenB = Keypair.generate();

it(&quot;initializes tokenA &amp; tokenB, each with balance 1000&quot;, async () =&gt; &#123;
  for (const tok of [tokenA, tokenB]) &#123;
    await program.methods
      .initTokenAccount()
      .accounts(&#123;
        token: tok.publicKey,
        owner: provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      &#125;)
      .signers([tok])
      .rpc();

    const acc = await program.account.tokenAccount.fetch(tok.publicKey);
    assert.equal(
      acc.owner.toBase58(),
      provider.wallet.publicKey.toBase58()
    );
    assert.equal(acc.balance.toNumber(), 1000);
  &#125;
&#125;);

it(&quot;transfers 250 from A to B (balances 750 / 1250)&quot;, async () =&gt; &#123;
  await program.methods
    .transfer(new BN(250))
    .accounts(&#123;
      from:  tokenA.publicKey,
      to:    tokenB.publicKey,
      owner: provider.wallet.publicKey,
    &#125;)
    .rpc();

  const a = await program.account.tokenAccount.fetch(tokenA.publicKey);
  const b = await program.account.tokenAccount.fetch(tokenB.publicKey);

  assert.equal(a.balance.toNumber(), 750);
  assert.equal(b.balance.toNumber(), 1250);
&#125;);
</code></pre>
<p>If you’re interested, try deploying this contract to devnet and interact with it using the SDK!</p>
</div></div></body><script src="/js/highlight.min.js"></script><script src="/js/main.js"></script><script src="/js/bootstrap/bootstrap.min.js"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-2615E2THFJ"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-2615E2THFJ');</script></html>