<!DOCTYPE html><html lang="en"><head><title>Kotlin: A Simplified Version of Scala</title><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="manifest" href="/site.webmanifest"><link rel="stylesheet" href="/css/highlight/xcode.min.css"><link rel="stylesheet" href="/css/bootstrap/bootstrap-tooltips.css"><link rel="stylesheet" href="/css/post.css"><script src="/js/jquery.min.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="smallyu‘s Blog" type="application/atom+xml">
</head><body><script>if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent)) {
  document.body.classList.add('mobile')
  var navbar = document.querySelector('nav.navbar');
  if (navbar) {
    navbar.classList.remove('navbar-fixed-top');
  }
}
</script><div><div class="inner"><h1>Kotlin: A Simplified Version of Scala</h1><div class="time">2019-07-06</div><ul class="tags"><li><span>#</span><a href="/tags/Programming-Languages/">Programming Languages</a></li></ul><p>A swordsman in the martial world must have a handy sword. A good programming language is like a good sword: the weight is appropriate, it feels comfortable, it’s elegant to wield, and its lethality is adequate. The official stance on Kotlin’s relationship with Scala is, “If you’re happy with Scala, you don’t need Kotlin.”</p>
<h3 id="Scripting"><a href="#Scripting" class="headerlink" title="Scripting"></a>Scripting</h3><p>Like Java, Scala’s basic unit of execution is a class, while Kotlin allows the main method in a file to run directly without requiring a class. Java’s entry function is defined within a class:</p>
<pre><code class="Java">public class Java &#123;
    public static void main(String[] args) &#123;&#125;
&#125;
</code></pre>
<p>Scala’s entry function is defined within an object rather than a regular class:</p>
<pre><code class="Scala">object Scala &#123;
  def main(args: Array[String]): Unit = &#123;&#125;
&#125;
</code></pre>
<p>Kotlin’s entry function is defined directly in a .kt file; thus, a class in Kotlin is merely a data structure where an entry function cannot be defined:</p>
<pre><code class="Kotlin">fun main(args: Array&lt;String&gt;) &#123;&#125;
</code></pre>
<h3 id="Constructors-and-Singleton-Pattern"><a href="#Constructors-and-Singleton-Pattern" class="headerlink" title="Constructors and Singleton Pattern"></a>Constructors and Singleton Pattern</h3><p>Kotlin’s constructor, like Scala’s, is written in the class definition, and thus cannot include initialization code directly as Java’s constructors can. In Kotlin, the init block is used to execute initialization code:</p>
<pre><code class="Kotlin">class Test(arg: String) &#123;
    init &#123;
        println(&quot;This string is $&#123;arg&#125;&quot;)
    &#125;
&#125;

fun main(args: Array&lt;String&gt;) &#123;
    val test = Test(&quot;smallyu&quot;)
&#125;

// This string is smallyu
</code></pre>
<p>If a second constructor is needed, you have to use a constructor function similar to ES6, or a secondary constructor like in Scala. This is indeed an awkward way of writing, making Java seem more user-friendly in comparison.</p>
<pre><code class="Kotlin">class Test(arg1: String) &#123;
    init &#123;
        println(&quot;This string is $&#123;arg1&#125;&quot;)
    &#125;
    constructor(arg2: Int): this(&quot;smallyu2&quot;) &#123;
        println(&quot;This int is $&#123;arg2&#125;&quot;)
    &#125;
&#125;

fun main(args: Array&lt;String&gt;) &#123;
    val test = Test(1)
&#125;

// This string is smallyu2
// This int is 1
</code></pre>
<p>Kotlin’s constructor needs to be defined with the constructor keyword, which can be omitted by default, but if you want to add access modifiers, you naturally can’t omit it. Implementing the singleton pattern in Kotlin is similar to Java: make the constructor private, and expose the instance through a static method:</p>
<pre><code class="Kotlin">class Test private constructor() &#123;
    companion object Factory &#123;
        fun create(): Test = Test()
    &#125;
&#125;

fun main(args: Array&lt;String&gt;) &#123;
    val test = Test.Factory.create()
&#125;
</code></pre>
<p>In Kotlin, the object keyword defines a static block, and companion allows defining static blocks within the class, hence the companion object defines a method create() that can be accessed externally.</p>
<h3 id="Getter-and-Setter"><a href="#Getter-and-Setter" class="headerlink" title="Getter and Setter"></a>Getter and Setter</h3><p>Another interesting feature in Kotlin is the getter and setter. The principle behind data binding in frontend frameworks like React or Vue is using Object.defineProperty() to define an object’s getter and setter, allowing changes to the object to be synchronized with the page in real-time. Kotlin provides support for property getters and setters:</p>
<pre><code class="Kotlin">var test: Int
    get() &#123;
        println(&quot;There is test getter&quot;)
        return 2
    &#125;
    set(arg) &#123;
        println(&quot;The setter arg is $&#123;arg&#125;&quot;)
    &#125;

fun main(args: Array&lt;String&gt;) &#123;
    println(test)
    test = 3
&#125;

// There is test getter
// 2
// The setter arg is 3
</code></pre>
<h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3><p>I became interested in Kotlin because I found that Kotlin supports coroutines. If Kotlin truly has language-level coroutine support, combined with its ability to run on the JVM and develop multi-platform applications including server-side, Android, JavaScript, and Native, Kotlin would undoubtedly be an extremely powerful programming language. However, Kotlin’s coroutines are just an extension package and still require a compiler tool to introduce, so Go language remains dominant in coroutine support. For the JavaScript platform, Kotlin is not as easy to use as TypeScript. As for Android and Native, they are already Java’s application scenarios…</p>
<p>Kotlin provides a lot of syntactic sugar, seemingly reducing the amount of code a programmer has to write, but to proficiently apply Kotlin’s features, users must understand concepts similar to data classes, just like Scala’s case classes. Kotlin is less academic than Scala and does not have a significant advantage over Java in terms of engineering capabilities. Although Go language takes a different path and has widely criticized language features, it is satisfying to read and write. Therefore, like Scala, Kotlin will not have a broad application prospect. In other words, it will not be the next popular programming language.</p>
</div></div></body><script src="/js/highlight.min.js"></script><script src="/js/main.js"></script><script src="/js/bootstrap/bootstrap.min.js"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-2615E2THFJ"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-2615E2THFJ');</script></html>