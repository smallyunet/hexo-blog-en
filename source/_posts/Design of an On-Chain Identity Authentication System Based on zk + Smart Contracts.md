---
title: Design of an On-Chain Identity Authentication System Based on zk + Smart Contracts
tags: 
- zk
- Plan
date: 2025-04-30 22:18:54
draft_date: 2025-04-30 21:59:39
---

I named this system zkgate.fun, aiming to leverage the features of zero-knowledge proofs combined with blockchain to create a small utility.

The main function is to allow users to prove that they belong to a certain group, without revealing their real (on-chain) identity.

Here's the current design idea: the administrator first has a list of names, which can be an array of Ethereum addresses. Based on this address list, a Merkle Root Hash is computed.

Then, this root hash is submitted to a smart contract.

People included in this list can use a proving key from a Circom circuit to generate a zk proof for themselves, and then submit the zk proof to the smart contract.

On the smart contract side, the `verifier.sol` generated by the Circom circuit will be used to verify the received zk proof, determine whether the address used to generate the zk proof is included in the Merkle Root Hash, and finally return the result of the verification.

In this way, the administrator doesn't need to reveal which addresses are in the group, and addresses that belong to the group don't need to declare their identity. They just need to submit a zk proof generated by the zero-knowledge proof system to prove that they indeed belong to the group.

Next, I will proceed to implement this design from a technical perspective.

<br>

### Update v0.1.0 Version (2025.05.09)

First, let's correct a previous design mistake: administrators must publicly share their group address list. Otherwise, it's impossible to generate a Merkle Tree based on the address list, and users won't be able to locate their address within the tree structure or generate a path proof.

Secondly, I'm happy to report that a very basic demo is now working ([smallyunet/zkgate-demo](https://github.com/smallyunet/zkgate-demo)). While this demo is quite rudimentary and doesn't yet verify address ownership within the circuit, it does demonstrate a functional toolchain.

Here's how the implementation works:

1. An [off-chain script](https://github.com/smallyunet/zkgate-demo/blob/main/offchain/smt.js) generates the zk circuit's [inputs.json](https://github.com/smallyunet/zkgate-demo/blob/main/offchain/inputs.json) from the address list and a user's own address. This input file includes the Merkle Root Hash and the path required to verify node position.
2. Based on the [circuit code](https://github.com/smallyunet/zkgate-demo/blob/main/circuits/merkleSmtProof.circom), it compiles some [binary files](https://github.com/smallyunet/zkgate-demo/tree/main/circuits/build), which are used to generate the witness file.
3. It uses a public [ptau file](https://github.com/smallyunet/zkgate-demo/blob/main/circuits/run.sh#L17-L28) to generate a .zkey file.
4. From the .zkey file, it exports [proof.json](https://github.com/smallyunet/zkgate-demo/blob/main/circuits/proof.json), [public.json](https://github.com/smallyunet/zkgate-demo/blob/main/circuits/public.json), and [verification_key.json](https://github.com/smallyunet/zkgate-demo/blob/main/circuits/verification_key.json). These three JSON files enable offline off-chain verification of the proof's validity.
5. It also exports a [.sol file](https://github.com/smallyunet/zkgate-demo/blob/main/circuits/contracts/Groth16Verifier.sol), i.e., the smart contract code, from the .zkey file to be deployed on-chain.
6. By supplying the contents of proof.json and public.json as [parameters](https://github.com/smallyunet/zkgate-demo/blob/main/hardhat/scripts/prove.js#L41), one can call the smart contract's [verifyProof](https://github.com/smallyunet/zkgate-demo/blob/main/circuits/contracts/Groth16Verifier.sol) function. It returns true if the proof is valid; otherwise, false.

If an address is not in the group list, two scenarios are possible:

1. If someone tries to generate an inputs.json using an [address not in the group list](https://github.com/smallyunet/zkgate-demo/blob/main/offchain/smt_non_member.js#L24), the circuit will directly reject it and throw an error during proof generation.
2. If someone tries to submit a fake [proof with the correct root](https://github.com/smallyunet/zkgate-demo/blob/main/hardhat/scripts/fakeProofWithCorrectRoot.js#L26) for on-chain verification, the proof will fail verification.

Currently, the biggest flaw in this initial demo is that the proof is built using plaintext addresses, such as:

```js
const members = [
  "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
  "0x70997970C51812dc3A010C7d01b50e0d17dc79C8",
  "0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC",
];

const proofKey = toField(members[0]);
const { siblings } = await tree.find(proofKey);
```

This code instructs the zk circuit to check whether `members[0]` is part of the Merkle tree constructed from the `members` array — and of course, it is. To construct a proof for a non-member address, one simply needs to replace the `proofKey`:

```js
const nonMemberAddress = "0x1234567890123456789012345678901234567890";
const proofKey = toField(nonMemberAddress);
const { siblings } = await tree.find(proofKey);
```

In other words, the `members` list must be public. Right now, the program can only verify whether an address is in the `members` array. But even if `members[0]` is not my address, I can still construct a valid proof with it. So what’s the point of zk?

The next step is to have users sign a message with their private key, then use the zk circuit to recover the address from the signature, and finally check whether the recovered address is in the `members` array.

Sounds simple, right? But in practice, recovering an address from an ECDSA signature within a zk circuit is not only extremely complex—it’s like trying to build a nuclear reactor out of LEGO. No wonder people say working with zk makes your hair fall out.
