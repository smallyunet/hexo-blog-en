---
title: What I Learned from Yin Wang's Computer Science Course
tags:
  - Learning
  - Yin Wang
date: 2025-07-24 12:12:12
first_date: 2025-07-08 03:08:42
draft_date: 2025-07-07 23:34:29
---

> For convenience, this article refers to "Yin Wang" by name without honorifics like "Professor Wang."

About two months ago, I enrolled in Yin Wang's [Computer Science Video Course](https://www.yinwang.org/blog-cn/2025/05/12/cs-video-course) (Fundamentals). I graduated after one month of study, which took approximately 120 hours in total. This “120 hours” was carefully estimated, including both video-watching and exercises. Since the pace is self-directed, describing the length in hours is clearer than saying "one month." 120 hours means, if you study two hours per day without breaks, it takes 60 days.

If I just said “studied for a month,” some might dismiss it—how much can you really learn in a month? There are no shortcuts in the world, and that includes Yin Wang. It’s true that one month is not enough to master a wide range of knowledge. But can a month help me sort through my past programming skills and give me a more systematic understanding of computer science? In my work, I’ve seen many things through a fog—can Yin Wang’s course help me see clearly?

I progressed quickly through the course, not because I was a beginner, but because I already had coding experience. I could usually write working code with ease, though not always elegant or concise. This skill had become muscle memory—like a primitive living in the jungle who hasn’t received formal combat training, yet is more physically adept than average people.

Now that a month has passed since graduation, I want to share what I’ve learned from the course. I didn’t summarize on graduation day, fearing it would be shallow or too personal. A month isn’t long enough for deep reflection either—I haven’t reviewed much and haven’t fully utilized what I learned—but summarizing now doesn’t stop future insights from forming. Yin Wang once wrote an article titled [Einstein on Education](https://yinwang-wiki.github.io/feeds/2013-04-03-einstein-on-education.html), quoting Einstein: "The knowledge imparted should be regarded as a precious gift." After finishing the course, I stumbled upon this article again, and that quote suddenly felt real.

Yin Wang doesn’t know me, but I’ve known of him for a long time. I wasn’t his student before, but he’s long been a teacher to me. I’ve followed his blog for years and learned a lot from his posts. Taking this video course felt like opening a door to a new world. That’s not an exaggeration—I can responsibly say from a student’s perspective that Yin Wang isn’t bluffing; the course really is as good as he claims. You may disagree with his views or dislike his life philosophy, but it’s impossible to doubt his research level in computer science, especially in programming languages. And given how seriously he treats both himself and the world, it’s inconceivable that he’d produce low-quality content just to deceive others.

Because the course content is confidential, I won’t reveal specific topics. I’ll only refer to what’s publicly mentioned in the course description. For beginners, the most straightforward things you’ll learn are fundamental programming concepts—functions, linked lists, binary trees—covering what a full undergraduate program might include. Lesson 6 on interpreters represents the course’s “final achievement,” comparable to what’s taught in advanced undergrad or early graduate-level CS courses in top U.S. universities. Why does Yin Wang describe it as "PhD-level content" in his course description? Because Chinese universities don’t offer majors in programming languages, undergrads aren’t taught interpreters, and even in grad school, lambda calculus is often elective. Learning about interpreters usually doesn’t happen until early PhD studies—so his claim isn’t an exaggeration.

Interpreter content is rare in China’s CS education system, and high-quality, refined tutorials are even rarer. For example, after finishing the course, if you search for interpreter tutorials on Bilibili, you’ll realize how poor those tutorials are—you’ll instantly spot what’s missing, what’s flawed, how to improve them, and how to write more reliable implementations with cleaner code. Why are interpreters important? Take Ethereum’s virtual machine (EVM) as an example—it’s an interpreter, not for a programming language, but for Ethereum’s opcodes. Each opcode corresponds to a stack operation. So, once you understand interpreters, you’ll see the EVM in a whole new light.

For experienced programmers, the course offers more than surface-level knowledge. For example, the course conveys everything from Lesson 1 to Lesson 6 using very few programming elements. Yin Wang must have an extraordinarily deep understanding of CS to achieve such elegant simplicity. As a student, you can reflect on why the material is so refined, how the course is structured, what kind of abstract thinking is required to reach that level, and how far your abilities are from being able to create such a course.

Moreover, the course is self-contained—you can eventually recreate the entire thing yourself. It’s like a finely crafted artifact you can return to and study anytime. The knowledge in the fundamentals course is like raw material. Graduating means you’ve acquired it, but it needs to be refined and forged into tools. I suspect this is why some students feel they didn’t learn anything, while others find it invaluable—they know how to make repeated use of it and create real value.

Recently, I suddenly realized that learning other technologies has become easier since taking the course. Because I experienced the layered, progressive teaching method, I naturally apply the same approach when self-learning: step by step. I learned Solana smart contracts, Bitcoin script, Bitcoin Runes, CPS (Continuation-Passing Style), coroutine scheduling with continuations... I can’t explain why this is happening. The course just covered basic CS—linked lists, binary trees, and so on—but somehow it has this kind of power. Maybe I didn’t just learn knowledge—I learned how to learn. No wonder Yin Wang calls the fundamentals course the "essence of computer science."

Even though I’ve worked in the blockchain industry for years, I’ve become increasingly unsure about what blockchain technology actually is. I used to focus heavily on blockchain consensus mechanisms. Why not on other foundational technologies like cryptography, distributed networking, or storage systems? Because consensus is unique to blockchain—everything else is just engineering, including smart contracts, which are not essential. Layer 2 solutions? Also just engineering attempts. Business-defined rules like challenge periods and withdrawal times have no abstract theoretical basis. Spoiler alert: Yin Wang’s course even touches on the essential technical principles of blockchain. Hard to believe? It’s true.

Compared to the fragmented engineering of blockchain, solid computer science fundamentals are crucial. Abstract thinking, understanding the essence of programming languages beyond syntax—these are worth mastering. I once believed that deeply diving into blockchain would naturally improve my skills, that eventually I’d surpass any "intro to CS" course. But reality didn’t align with that belief. So I took this course—and learned a lot.

Afterward, I started to doubt myself. Did all these years of blockchain work mean nothing? Why did a beginner-level CS course feel so life-changing? I couldn’t figure it out. Until I came across Yin Wang’s article on [Designing the CS Course](https://www.yinwang.org/blog-cn/2020/03/03/cs-course), and especially the part about the "Socratic method." That’s when it clicked: my knowledge had long been scattered in my mind—this course simply helped "deliver" it. The knowledge I now have came from years of work and study as "pregnancy," and this course served as the timely "midwife."

> Socrates admitted he had no knowledge himself, yet still taught others. His solution to this paradox was that knowledge is not something he instills, but something people already possess. People are already "pregnant" with knowledge; they just don’t realize it. Socrates, like a "midwife," helps them give birth to it.

It’s like wandering in a foreign city without a map—you can go far, but you’re always disoriented. The fundamentals course is like receiving a complete map. You now clearly see the paths and intersections. You may not travel far, but you understand the terrain. I had already walked many roads in this city. One day, I got the map—and everything suddenly made sense.

Yin Wang recently commented on Weibo that AI can't write "Yin Wang-level" code. What does that mean? You’ll understand after taking the course. When doing exercises, the TA often pointed out my code was "too complex"—sometimes in structure, sometimes in algorithmic complexity. But every time I refined it to match the course’s standard, I was amazed by the elegance possible in code. I’ve been coding for years—getting a program to work isn’t hard. But writing beautiful code? That’s hard. If I had written code this clean at work, the company would’ve greatly benefited.

And more than that—some may doubt the course description: "Can one elective class really teach you a new programming language?" I’d just remind you—don’t forget who’s teaching the class. He’s a true programming language expert.
